import r from"fs-extra/lib/index.js";import{parse as e}from"@babel/parser/lib/index.js";import t from"@babel/traverse/lib/index.js";import o from"fs-extra/lib/index.js";import n from"path";import s from"camelcase/index.js";import{pascalCase as a}from"pascal-case/dist/index.js";function i(r){const e={},t=Object.keys(r);for(const o of t)e[r[o]]=o;return e}function p(r){switch(r.type){case"StringLiteral":case"Literal":return r.value;case"BinaryExpression":if("+"!==r.operator)throw new Error("Unsupported binary operator "+r.operator);return p(r.left)+p(r.right);default:throw new Error("Unsupported type "+r.type)}}const c=o.realpathSync(process.cwd()),l=function(r){return n.resolve(c,r)},u={appPackageJson:l("package.json"),tsconfigJson:l("tsconfig.json"),testsSetup:l("test/setupTests.ts"),appRoot:l("."),appSrc:l("src"),appErrorsJson:l("errors/codes.json"),appErrors:l("errors"),appDist:l("dist"),appConfig:l("export-ts.config.js"),jestConfig:l("jest.config.js"),progressEstimatorCache:l("node_modules/.cache/.progress-estimator")},f={sourceType:"module",plugins:["classProperties","flow","jsx","trailingFunctionCommas","objectRestSpread"]};async function m(o){if(!o||!o.errorMapFilePath)throw new Error("Missing options. Ensure you pass an object with `errorMapFilePath`.");if(!o.name||!o.name)throw new Error("Missing options. Ensure you pass --name flag to export-ts");const n=o.errorMapFilePath;let c;try{const e=await r.readFile(n,"utf-8");c=JSON.parse(e)}catch(r){c={}}const l=Object.keys(c);let m;function d(r){const o=e(r,f);t(o,{CallExpression:{exit(r){var e;r.get("callee").isIdentifier({name:"invariant"})&&(e=p(r.node.arguments[1]),c.hasOwnProperty(e)||(c[e]=""+m++))}}})}return m=0===l.length?0:Math.max.apply(null,l)+1,c=i(c),async function(e){d(e),await async function(){const e=a((r=>s((r=>r.replace(/^@.*\//,""))(r).toLowerCase().replace(/((^[^a-zA-Z]+)|[^\w.-])|([^a-zA-Z0-9]+$)/g,"")))(o.name));await r.ensureDir(u.appErrors),await r.writeFile(n,JSON.stringify(i(c),null,2)+"\n","utf-8"),await r.writeFile(u.appErrors+"/ErrorDev.js","\nfunction ErrorDev(message) {\n  const error = new Error(message);\n  error.name = 'Invariant Violation';\n  return error;\n}\n\nexport default ErrorDev;\n      ","utf-8"),await r.writeFile(u.appErrors+"/ErrorProd.js",`\nfunction ErrorProd(code) {\n  // TODO: replace this URL with yours\n  let url = 'https://reactjs.org/docs/error-decoder.html?invariant=' + code;\n  for (let i = 1; i < arguments.length; i++) {\n    url += '&args[]=' + encodeURIComponent(arguments[i]);\n  }\n  return new Error(\n    \`Minified ${e} error #\${code}; visit \${url} for the full message or \` +\n      'use the non-minified dev environment for full errors and additional ' +\n      'helpful warnings. '\n  );\n}\n\nexport default ErrorProd;\n`,"utf-8")}()}}export{m as extractErrors};
export default {};
//# sourceMappingURL=extractErrors.mjs.map
